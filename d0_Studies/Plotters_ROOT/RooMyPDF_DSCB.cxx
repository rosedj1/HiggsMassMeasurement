/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooMyPDF_DSCB.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(RooMyPDF_DSCB) 

 RooMyPDF_DSCB::RooMyPDF_DSCB(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _mean,
                        RooAbsReal& _sigma,
                        RooAbsReal& _alphaL,
                        RooAbsReal& _expL,
                        RooAbsReal& _alphaR,
                        RooAbsReal& _expR) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   mean("mean","mean",this,_mean),
   sigma("sigma","sigma",this,_sigma),
   alphaL("alphaL","alphaL",this,_alphaL),
   expL("expL","expL",this,_expL),
   alphaR("alphaR","alphaR",this,_alphaR),
   expR("expR","expR",this,_expR)
 { 
 } 


 RooMyPDF_DSCB::RooMyPDF_DSCB(const RooMyPDF_DSCB& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   mean("mean",this,other.mean),
   sigma("sigma",this,other.sigma),
   alphaL("alphaL",this,other.alphaL),
   expL("expL",this,other.expL),
   alphaR("alphaR",this,other.alphaR),
   expR("expR",this,other.expR)
 { 
 } 


 double RooMyPDF_DSCB::evaluate() const
 {
   double t = (x-mean)/sigma;
   if(t>=-alphaL && t<=alphaR){
     return exp(-0.5*t*t);
   }else if(t<-alphaL){
     double A1 = pow(expL/fabs(alphaL),expL)*exp(-alphaL*alphaL/2);
     double B1 = expL/fabs(alphaL)-fabs(alphaL);
     return A1*pow(B1-t,-expL);
   }else if(t>alphaR){
     double A2 = pow(expR/fabs(alphaR),expR)*exp(-alphaR*alphaR/2);
     double B2 = expR/fabs(alphaR)-fabs(alphaR);
     return A2*pow(B2+t,-expR);
   }else{
     cout << "ERROR evaluating range..." << endl;
     return 99;
   }

 }

 Int_t RooMyPDF_DSCB::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* range) const
 { 
   if (matchArgs(allVars,analVars,x)) return 1;
   return 0;
 }


 Double_t RooMyPDF_DSCB::analyticalIntegral(Int_t code, const char* rangeName) const
 {
   assert(code==1) ;

   double central=0;
   double left=0;
   double right=0;

   static const Double_t root2 = sqrt(2) ;
   static const Double_t rootPiBy2 = sqrt(atan2(0.0,-1.0)/2.0);
   Double_t xscale = root2*sigma;

   //compute gaussian contribution
   double central_low =max(x.min(rangeName),mean - alphaL*sigma );
   double central_high=min(x.max(rangeName),mean + alphaR*sigma );
   if(central_low < central_high) // is the gaussian part in range?
   central = rootPiBy2*sigma*(TMath::Erf((central_high-mean)/xscale)-TMath::Erf((central_low-mean)/xscale));
   
   //compute left tail;
   double A1 = pow(expL/fabs(alphaL),expL)*exp(-alphaL*alphaL/2);
   double B1 = expL/fabs(alphaL)-fabs(alphaL);
   //
   double left_low=x.min(rangeName);
   double left_high=min(x.max(rangeName),mean - alphaL*sigma);
   if(left_low < left_high){ //is the left tail in range?
       if(fabs(expL-1.0)>1.e-5)
         left = A1/(-expL+1.0)*sigma*(pow(B1-(left_low-mean)/sigma,-expL+1.)-pow(B1-(left_high-mean)/sigma,-expL+1.));
       else
         left = A1*sigma*(log(B1-(left_low-mean)/sigma) - log(B1-(left_high-mean)/sigma) );
   }

   //compute right tail;
   double A2 = pow(expR/fabs(alphaR),expR)*exp(-alphaR*alphaR/2);
   double B2 = expR/fabs(alphaR)-fabs(alphaR);
   double right_low=max(x.min(rangeName),mean + alphaR*sigma);
   double right_high=x.max(rangeName);
   if(right_low < right_high){ //is the right tail in range?
     if(fabs(expR-1.0)>1.e-5)
       right = A2/(-expR+1.0)*sigma*(pow(B2+(right_high-mean)/sigma,-expR+1.)-pow(B2+(right_low-mean)/sigma,-expR+1.));
     else
       right = A2*sigma*(log(B2+(right_high-mean)/sigma) - log(B2+(right_low-mean)/sigma) );
   }
   
   return left+central+right;

 } 